# shell基础

可以通过/etc/shells文件来查询Linux支持的Shell

```shell
#!/bin/bash,这段用来标明我下面的是shell程序，告诉机器用什么编译
```

### 2.输入输出重定向

​    2.1 Bash的标准输入输出

​     

| 设备   | 设备文件名  | 文件描述符 | 类型         |
| ------ | ----------- | ---------- | ------------ |
| 键盘   | /dev/stdin  | 0          | 标准输入     |
| 显示器 | /dev/stdout | 1          | 标准输出     |
| 显示器 | /dev/stderr | 2          | 标准错误输出 |

2.2 输出重定向

| 类型                       | 符号                                     | 作用                                                       |
| -------------------------- | ---------------------------------------- | ---------------------------------------------------------- |
| 标准输出重定向             | 命令  > 文件                             | 以覆盖的方式吧命令的正确输出输出到指定的文件或设备当中     |
| 标准输出重定向             | 命令　＞＞　文件                         | 以追加的方式，把命令的正确输出输出到指定的文件或设备当中   |
| 标准错误输出重定向         | 错误命令　２＞文件                       | 以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中   |
| 标准错误输出重定向         | 错误命令　２＞＞文件                     | 以追加的方式，把命令的错误输出输出到指定的文件或设备当中   |
| 正确输出和错误输出同时保存 | 命令> 文件2>&1                           | 以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中   |
| 正确输出和错误输出同时保存 | 命令>>文件 2>&1，(注意，2后面不能有空格) | 以追加的方式，把正确输出和错误输出都保存到同一个文件当中   |
| 正确输出和错误输出同时保存 | 命令 & >文件 1                           | 以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中   |
| 正确输出和错误输出同时保存 | 命令 &>>文件                             | 以追加的方式，把正确的输出和错误的输出都保存到同一个文件中 |
| 正确输出和错误输出同时保存 | 命令>>文件1 2>>文件2                     | 把正确的输出追加到文件1，把错误的输出追加到文件2           |

wc命令

```shell
wc [选项] [文件名]
-c  统计字节数
-w 统计单词数
-l 统计行数
```



2.3多命令顺序执行

```shell
#不管前面的命令是否正确执行，后面的都执行
ls  ;  data  ; cd /etc ;

#如果前面的命令执行错误，则后面的命令不会执行
命令1 && 命令2

#如果前面的命令执行不正确，则后面的命令才执行，负责后面的命令不执行
命令1 || 命令2

ls && ech yes || echo no
```

2.4 grep

```shell
grep [选项] "搜索文件内容" 文件名
选项:
  -A 数字:  列出符合条件的行，并列出后续的行
  -B 数字: 列出符合条件的行，并列出前面的n行
  -c:统计找到的符合条件的字符串的次数
  -i:忽略大小写
  -n:输出行号
  -v:反向查找
  
  
  
注意:find命令时可以通过-regex选项识别正则表达式的规则，也就是说find命令可以按照正则表达式规则匹配，而正则表达式是模糊匹配，但是对于初学者而言，find命令和grep命令本身就不好理解，所以我们这里只安照通配符规则来进行find查询

通配符和正则的区别:通配符时用来匹配文件名的，正则是用来匹配字符串的
```

2.5 通配符

| 通配符 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| ？     | 匹配一个任意字符                                             |
| \*     | 匹配0个或任意多个任意字符，也就是可以匹配任何内容            |
| []     | 匹配中括号中任意一个字符，[abc]代表一定匹配一个字符，或者a,或者b,或者c |
| [-]    | 匹配中括号中任意一个字符，-代表一个范围，例如:[a-z]代表匹配一个小写字母 |
| [^]    | 逻辑非，表示匹配不上中括号内的一个字符。例如[^0-9]代表匹配不是一个数字的字符 |

```shell
a=`data`,这个反引号表示告诉系统把命令data运行的结果值赋值给变量a,$()的作用和``的作用是一样的，建议使用$(),因为方便看

单引号括起来的命令会原样输出，双引号括起来的命令会有命令的执行结果

#在shell中，小括号括起来的命令，相对于在当前的bash窗口下面再开启一个子bash，再执行括号里面的内容，括号里面的内容执行结束之后，退出子shell，回到父shell
(name=lm,echo $name)

#大括号中，直接在当前bash窗口中执行括号中的命令，注意，大括号第一个命令和左括号之间必须要有一个空格，最后一个命令要加;
{ name=lm,echo $name; }
```



# 变量

​    1.变量的命名

```shell
#变量名称可以由字母数字和下划线组成，但是不能以数字开头，如果变量名时"2name"，则是错误的
#在Bash中，变量的默认类型都是字符串类型，如果要进行数值运算，则必须指定变量类型为数值型
#变量用等号连接值，等号两侧不能有空格
#变量的值如有有空格，需要使用单引号或双引号括起来，如:test="heppo world"，其中双引号括起来的内			容"$"，"\"和反引号都拥有特殊含义，而单引号括起来的内容都是普通字符。
#在变量的值中，可以使用\转义字符
#如果需要增加变量的值，那么可以进行遍历值的叠加。不过变量需要用双引号包含"$变量名"或用${变量名}包含变量名
   test=123  echo "$test"123输出结果就是123123 或者写成 echo ${test}123
#如果要把命令的结果作为变量值赋予变量，则需要使用反引号或$()包含命令。例如:
```

2. 变量的分类

   ```shell
   #用户定义变量
   #环境变量
   #位置参数变量:这种变量主要用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的
   #预定义变量:是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的
   
   其中，环境变量，位置参数变量，预定义变量的作用，名称都是确定的，值是自定义的
   如果用$变量名来输出的变量是空，那么就有两种情况，一种情况是这个变量没有定义，另一种情况是变量的值是空
   ```

3. 变量查看

   ```shell
   set [选项]
   -u：如果设定此选项，调用未声明变量时会报错(默认无任何提示)
   -x:如果设定此选项，在命令执行之前，会把命令先输出一次
   直接使用set命令，会查询系统中所有的变量，包含用户自定义变量和环境变量
   ```

4. 变量删除

   ```shell
   unset 变量名
   ```

5. 环境变量

   ```shell
   #环境变量的设置,使用export声明的变量即是环境变量
   export age="18"
   
   #环境变量的查询和删除
   env命令和set命令的区别，set命令可以查看所有变量，而env命令只能查看环境变量
   unset 环境变量
   只删除自定义的环境变量，不要删除系统自带的环境变量
   ```

6. PATH变量

   ```shell
   path变量:系统查找命令的路径
   #先查询一下path环境变量的值 
     echo $PATH
    #我们是不是可以修改PATH变量的值，而不是把程序脚本复制到/bin/目录中。当然是可以的，我们通过变量的叠加就	可以实现了,在遍历PATH变量的后面，加入/root/sh目录，当然我们这样定义的PATH变量值是临时生效，一旦重启或注销就会消失，如果想要永久生效，需要写入环境变量配置文件。
    PARH="$PATH":/root/sh
   ```

7. PS1变量

   ```shell
   #PS1是用来定义命令提示符的，可以按照我们自己的需求来定义喜欢的提示符。PS1可以支持以下选项:在 /etc/bashrc目录下面修改
   ```

   | 选项 | 作用                                                         |
   | ---- | ------------------------------------------------------------ |
   | \d   | 显示日期，格式为"星期  月  日"                               |
   | \H   | 显示完整的主机名，如默认主机名"localhost.localdomain"        |
   | \h   | 显示简写主机名，如果默认名"localhost"                        |
   | \t   | 显示24小时时间，格式为"HH:MM:SS"                             |
   | \T   | 显示12小时时间制，格式为"HH:MM:SS"                           |
   | \A   | 显示24小时时间制，格式为"HH:MM"                              |
   | \@   | 显示24小时时间，格式为"HH:MM am/pm"                          |
   | \u   | 显示当前用户名                                               |
   | \v   | 显示Bash的版本信息                                           |
   | \w   | 显示当前所在目录的完整名称                                   |
   | \W   | 显示当前所在目录的最后一个目录                               |
   | \\#  | 执行的第几个命令                                             |
   | \s   | 提示符，如果是root用户会显示提示符为"#",如果是普通用户，会显示提示符为"\$" |

8. Linux中文支持

   ```shell
   echo $LANG
   
   #查询本机支持多种语系
   locale -a | more
   #系统默认的语系配置文件路径  /etc/sysconfig/i18n
   
   #如果是纯字符界面(本地终端 tty1-tty6)是不能显示中文的，因为Linux的纯字符界面是不能显示中文这么复杂的编码的，如果我们非要在纯字符界面显示中文，那么只能按装中文插件，如zhcon等
   ```

9. 位置参数变量

   | 位置参数变量 | 作用                                                         |
   | ------------ | ------------------------------------------------------------ |
   | \$n          | n为数字，\$0代表命令本身，\$1-\$9代表第一到第九个参数，十以上的参数都要用大括号包括，如\${10} |
   | \$*          | 这个变量代表命令行中所有的参数，\$*把所有的参数看成一个整体  |
   | \$@          | 这个变量也代表命令中中所有的参数，不过\$@把每个参数区分对待  |
   | \$#          | 这个变量代表命令行中所有参数的个数                           |

   ```shell
   #!/bin/bash
   a=$1
   b=$2
   sum=$(($a+$b))
   
   #如果上面的代码的文件名时count.sh,那么我们在执行./count.sh 22 23这个命令的时候，系统会自动把22传给$1,23传给$2
   
   #$*和$@的区别，第一个循环了一次，把所有的数都输出来了，第二个循环，输入了几个数，就循环了几次
   for  i in "$*"
      do
         echo $i
      done
      
   for y in "$@"
       do 
          echo  $y
       done
   ```

10. 预定义变量

    | 预定义变量 | 作用                                                         |
    | ---------- | ------------------------------------------------------------ |
    | \$?        | 最后一次执行的命令的返回状态，如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0(具体是哪个数，由命令自己决定)，则证明上一个命令执行不正确了 |
    | $$         | 当前进程的进程号PID                                          |
    | \$!        | 后台运行的最后一个进程的进程号PID                            |

11. 接收键盘输入

    ```shell
    read  [选项] [变量名]
    选项:
      -p "提示信息"  在等待read输入时，输出提示信息
      -t 秒数:read命令会一直等待用户输入，使用此选项可以指定等待时间
      -n 字符数:read命令只接受指定的字符数，就会执行
      -s:隐藏输入的数据，适用于机密信息的输入
      
    变量名:
       变量名可以自定义，如果不指定变量名，会把输入保存到默认变量reply(大写)
       如果只提供了一个变量名，则整个输入行赋予该变量
       如果提供了一个以上的变量名，则输入行分为若干个字，一个接一个地赋予各个变量，而命令行上
       
       
       脚本实例:
     #!/bin/bash
     read -t 30 -p "please input your name：" name
     read -t 30 -p "please input a num2"： num2
     sum=$(($name+$num2))
     echo $sum
    ```

12. Shell的运算符

    既然所有变量的默认类型是字符串类型，那么只要我们把变量声明为整数类型不就可以运算了吗？使用declare命令就可以实现声明变量的类型，命令如下:

    ```shell
    declare [+/-][选项] 变量名
    选项:
       -：给变量设定类型属性
       +：取消变量的类型属性
       -a:将变量声明为数组型
       -i:将变量声明为整数型
       -r:将变量声明为只读变量，注意，一旦设置为只读变量，即不能修改变量的值，也不能删除变量，甚至不能通过+r		取消只读属性
       -x:将变量声明为环境变量
       -p:显示指定变量的被声明类型
       
       
      #我们其实也可以使用declare命令把变量声明为环境变量和export命令的作用是一样的
      declare -x test="123"
       
       
      实例
      第一整数变量
      declare -i cc=1+1
      
      定义数组
      declare -a name[0]="sc" 或 name[1]="lfk"
      echo ${name}#这种输出方法只能输出第一个下标变量
      echo ${name[*]}
    ```

    

    ##### 使用expr或let数值运算工具

    要进行数值运算的第二种方法是使用expr命令，这种命令就没有declare命令复杂了。命令如下

    ```shell
    aa=11
    bb=12
    dd=$(expr $aa + $bb)#注意，expr里面的+号两边必须要有空格
    let d=$aa+$bb 这个命令跟上面的命令功能是一样的
    ```

    

    ##### 推荐使用的运算符

      使用"\$(())"或"\$[运算式]"方式运算，后面一种不推荐

    ```shell
    a=23
    b=24
    c=$(($a+$b))
    
    
    #计算器实例:这个例子没有是数值的判断，如果输入的是字母，没有提示,exit表示退出程序
    #!/bin/bash
    read -t 30 -p "please input num1: " num1
    read -t 30 -p "please input num2: " num2
    read -n1 -t 30 -p "please input operato[+-*/]: " oper
    [ "$oper" == "+" ] && echo "$(($num1 + $num2))" && exit
    [ "$oper" == "-"] && echo "$(($num1 - $num2))" && exit
    [ "$oper" == "*"] && echo "$(($num1 * $num2))" && exit 
    [ "$oper" == "/"] && echo "$(($num1 / $num2))" && exit 
    ```



# 环境变量配置文件

1. source 命令

   ```shell
   source 配置文件，让配置文件不用重启就生效
   ```

2. 环境变量配置文件

   2.1 登录时生效的环境变量配置文件

          ```shell
   在linux系统登录时主要生效的环境变量配置文件有以下5个:
   /etc/profile
   /etc/profile.d/*.sh
   ~/.bash_profile
   ~/.bashrc
   /etc/bashrc
   
       ```
   
          ```
   
   ```mermaid
   graph LR
    A["/etc/profile"] --> B["~/.bash_profile"]-->C["~/.bashrc"]--> D["/etc/bashrc"]-->E["命令提示符"]
   A["/etc/profile"]-->F["/etc/prome.d/*.sh"]-->G["/etc/profile.d/lang.sh"] -->H["/etc/syscconfig/i1bn"]
D["/etc/bashrc"]-->F["/etc/profile.d/*.sh"]
   
   ```
   
   ```shell
   #在用户登录过程先调用/etc/profile文件,在这个环境变量配置文件中会定义这些默认环境变量
     user变量:根据登录的用户，给这个变量赋值(就是让user的变量的值是当前用户)
     longame变量:根据user变量的值，给这个变量赋值
     mail变量:根据登录的用户，定义用户的邮箱为/var/spool/mail/用户名
     path变量:根据登录用户的uid是否为0，判断path变量是否包含/sbin,/usr/sbin和/usr/local/sbin这三个系统命令目录
     hostname变量：更加主机名，给这个变量赋值
     histsize变量:定义历史命令的保存条数
     umask：定义umask默认权限，注意/etc/profile文件中umask权限是在"有用户登录过程,也就是输入了用户名和密码"时才会生效
     调用/etc/profile.d/*.sh文件，也就是调用/etc/profile.d/目录下所有以.sh结尾的文件。
     用户登录过程时，/etc/profile.d/*.sh文件已经被/etc/profile文件调用过了。
  这样这五个环境变量配置文件会被依次调用，那么我们自己定义的环境变量应该放入哪个文件呢？如果你的修改是打算对所有用户生效的，那么可以放入/etc/profile环境变量配置文件；如果你的修改只是给自己使用的，那么可以放入~/.bash_profile或~/.bashrc这两个配置文件中的任意一个。
     可是如果我们误删了这些环境变量，不如删除了/etc/bashrc文件或删除了~/。bashrc文件，那么这些文件中配置就会失效(~/.bashrc文件会调用/etc/bashrc文件)。那么我们的提示符就会变成: -bash-4.1#,因为PS1的配置文件在/etc/bashrc
```
   
2.2注销时生效的环境变量配置文件
   
​      在用户退出登录时，只会调用一个环境变量配置文件，就是~/.bash_logout,这个文件默认没有写入任何内容，可是如果我们希望再退出登录时执行一些操作，比如清楚历史命令，备份某些数据，就可以把命令写入这个文件
   
2.3 /etc/issu配置文件
   
​     可以支持的转义符我们可以通过man agetty命令查询，在表中我们列出常见的转义字符作用
   
    
   
   | 转义符 | 作用                            |
   | ------ | ------------------------------- |
   | \d     | 显示当前系统日期                |
   | \s     | 显示操作系统名称                |
   | \l     | 显示登录的终端号，这个比较常用  |
   | \m     | 显示硬件体现结果，如i386,i686等 |
   | \n     | 显示主机名                      |
   | \o     | 显示域名                        |
   | \r     | 显示内核版本                    |
   | \t     | 显示当前系统时间                |
   | \u     | 显示当前登录用户的序列号        |




# 正则表达式

1. 基础正则表达式

   | 元字符    | 作用                                                         |
   | --------- | ------------------------------------------------------------ |
   | \*        | 前一个字符匹配0次或任意多次，包括空白行业可以查出来，aa*表示最少包含一个a，如果a\* 表示有没有a都匹配 |
   | .         | 匹配除了换行符外任意一个字符                                 |
   | ^         | 匹配行首，例如^hello会匹配以hello开头的行                    |
   | \$        | 匹配行尾，例如:hello$会匹配以hello结尾的行                   |
   | []        | 匹配中括号中指定的任意一个字符，只匹配一个字符。例如[aoeiu]匹配任意一个元音字母，[0,9]匹配任意一个数字，[a-z]\[0-9]匹配小写字母和一位数字构成的两位字符 |
   | [^]       | 匹配除了中括号的字符以外的任意一个字符。例如[\^0-9]匹配任意一位非数字字符，[\^a-z]匹配任意一位非小写字母 |
   | \\{n\\}   | 表示其前面的字符恰好出现n次。例如[0-9]\\{4\\}匹配4位数字[1]\[3-8]\[0-9]\\{9\\}匹配手机号 |
   | \\{n,\\}  | 表示其前面的字符出现不小于n次。例如[0-9]\\{2,\\}表示两位及以上的数字 |
   | \\{n,m\\} | 表示其前面的字符最少出现n次，最多出现m次。例如:[a-z]\\{6,8\\}匹配6-8位的小写字母 |

   ```shell
   ".*"表示匹配任意一个字符
   ".$"表示以任意字符结尾
   "\.$"表示以.结尾
   "^$"表示匹配空白行
   grep -v的命令是取反的意思
   grep -v "^$"这条命令的意思是匹配除了空白行的其它行，-v是取反的意思
   注意，正则表达式都是包含匹配
   [0-9]表示匹配包含数字的行，不管有多少个
   #[^0-9]表示匹配包含除了数字的行
   #^[0-9]表示匹配以数字开头的行
   #^[^0-9]表示匹配不是以数字开头的行
   grep "a\{3\}" 表示匹配连续出现3个a的行
   grep "a\{3,\}" 表示匹配连续出现3个a以上的行
   需要注意的是，正则表达式是包含匹配，如果要确定要找只包含三个数字，不多不少，那么就要在前后加一些限定符，例如:grep "^[0-9]\{3\}[a-z]"
   
   grep "a\{3\}"这个表达式匹配的是连续有3个a在一块的行会匹配到，连续4个a及以上的行业能匹配到
   grep "[us]a\{3\}[il]"这个表单是匹配的是在a的前面要么是u，要么是s，在a的后面要么是i，要么是l
   ```

2. 扩展正则表达式

​                正则表达式中可以支持一些元字符，比如"+","?","|","()"。其实Linux是支持这些元字符的，只是grep命令默认不支持而已。如果要想支持这些元字符，必须使用egrep命令或grep -E选项，所以我们又把这些元字符称作为扩展元字符。

​            如果查询grep的帮助，对egrep的说明就是和grep -E选项一样的命令，所以我们可以把两个命令当做别名来对待。

| 扩展元字符 | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| +          | 前一个字符匹配一次或任意多次，如"go+gle"会匹配"gogle","google","gooogle",当然如果"o"有更多个，也能匹配 |
| ？         | 前一个字符匹配0次或1次                                       |
| \|         | 匹配两个或多个分支选择，如"was\|his"会匹配即包含"was"的行，也匹配包含"his"的行 |
| ()         | 匹配其整体为一个字符，即模式单元。可以理解为由多个单字符组成的大字符。如"(dog)+"会匹配"dog","dogdog","dogdogdog"等，因为被()包含的字符会当成一个整体， |

3. 正则实例

   ```shell
   匹配邮箱
   [0-9a-zA-Z_]+@[0-9a-zA-Z]+(\.[0-9a-zA-Z]+){1,3}
   #[0-9a-zA-Z_]+ 表示数字，字母匹配一次或任意多次
   #@[0-9a-zA-Z]+ 表示数字，字母匹配一次或任意多次
   ```

# 字符截取和替换命令

   1. cut列提取命令

      ```shell
      cut [选项] 文件名
      选项:
         -f 列号: 提取第几列
         -d 分隔符: 安照指定分隔符分割列
         -c 字符范围: 不依赖分隔符来区分列，而是通过字符范围(行首为0)来进行字段提取。"n-"表示从第n个字符到行尾；"n-m"从第n个字符到第m个字符；"-m"表示从第一个字符到第m个字符
         
         实例
         cut -f 2 student.txt 表示在student.txt这个文件中提取第二列，当是这个文件中不能有空格，因为cut							命令不识别空格
         grep -v "Name" student.txt | cut -f 2 这个命令表示先找到不包含Name的行，然后再用cut命令提取								第二列
         cut -f 2,3 student,txt表示提取第二列和第三列
         
      ```

      2. awk基本使用

         ```shell
         awk '条件1{动作1} 条件2{动作2}...' 文件名
         条件(Pattern)：
         一般使用关系表达式作为条件。这些关系表达式非常多，具体参考表12-3所示，例如:
         x > 10 判断变量x是否大于10
         A ~ B 判断字符串A中是否包含能匹配B表达式的子字符串
         A ！~B判断字符串A中是否不包含匹配B表达式的子字符串
         动作(action)：
           格式化输出
           流程控制语句
           
           
           实例:
           awk '{print $2 "\t" $6}' student.txt
           df -h awk '{print $5}'  表示提取第5列
           df -h | grep "dev/sda3" | awk '{print $5}' | cut -d "%" -f 1
         ```

         2.1 awk的条件

                  ```
      awk 'BEGIN {print 111} {print $2 "\t" $6}' student.txt
      awk 'end {print 1111} {print $2 "\t" $6}' student.txt
      grep -v "Name" student.txt | awk '\$6 >=86 {print \$2 }'
      awk $2 ~ /Sc/ {printf  "\n"} student.txt这个表示如果第二列中输入包含Sc字符，则打印第六列的数据
      上面需要注意的是，在awk中，使用"//"包含的字符串，awk命令才会查找，也就是说字符串必须用"//"包含，awk命令才能正确识别
      awk '/Liming/ {print $6}' student.txt这个是在整行中查找，并打印第六列的值
                  ```

      2.2. awk内置变量

      | awk内置变量 | 作用                                                         |
      | ----------- | ------------------------------------------------------------ |
      | \$0​         | 代表目前awk所读入的整行数据。我们已知awk是一行一行读入数据的，\$0就代表当前读入行的整行数据 |
      | \$n         | 代表目前读入行的第n个字段                                    |
      | NF          | 当前行拥有的字段(列)总数                                     |
      | NR          | 当前awk所处理的行，是总数据的第几行                          |
      | FS          | 用户定义分隔符。awk的默认分隔符是任何空格，如果想要其他分隔符(如":")就需要FS变量定义 |
      | ARGC        | 命令行参数个数                                               |
      | ARGV        | 命令行参数数组                                               |
      | FNR         | 当前文件中的当前记录数(对输入文件起始为1)                    |
      | OFMT        | 数值的输出格式(默认为%.6g)                                   |
      | OFS         | 输出字段的分隔符(默认为空格)                                 |
      | ORS         | 输出记录分隔符(默认为换行符)                                 |
      | RS          | 输入记录分隔符(默认为换行符)                                 |

      ```shell
      cat /etc/passwd | grep "/bin/bash" | awk '{FS=":"} {print $1}'
      #什么命令的执行结果
      root:x:0:0:root:/root:/bin/bash
      user1
      user2
      之所以第一行全部输出来了是因为awk默认先读取第一行，等到第二行然后才执行动作({FS=":"})，要想解决这个问题，我们需要这些修改命令
      cat /etc/passed | grep "/bin/bash" | awk 'BEGIN{FS=":"} {print $1}'
      ```


3. sed命令

   sed是一个流编辑器，什么是流编辑器？将文件或标准输入的内容作为编辑对象，对其按照需求进行修改

   pattern space是什么:在流编辑器中有pattern space的概念，翻译为:模式空间。简单理解就是一个缓冲区，sed从输入流中一行一行的取出内容放到这个缓冲区中按照script(脚本)进行处理
   
   sed主要是用来将数据进行选取、替换、删除、新增的命令，我们看看命令的语法
   
   ```shell
   sed [选项] '[动作]' 文件名
   选项:
     -n:一般sed命令会把所有数据都输出到屏幕，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕
     -e:允许对输入数据应用多条sed命令编辑
     -f 脚本文件:从sed脚本中读入sed操作。和awk命令的-f非常类似
     -r:在sed中支持扩展正则表达式
     -i:用sed的修改结果直接修改读取数据的文件，而不是屏幕输出动作
     
   动作:
     a\:追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用\代表数据未完结
     c\:行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需要用\代表数据未完结
     i\:插入，在当期行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用"\"代表数据未完结。
     d:删除，删除指定的行
     s:字符串替换，用一个字符串替换另外一个字符串，格式为"行范围 s/旧字符串/新字符串/g"(和vim中的替换格式类似)
     
     
     sed '2p' student.txt 表示打印第二行，这个命令首先会输出第一行，然后在输出这个文件里面的所有行
     sed '2p -n' student.txt这个命令表示只输出第二行
     sed -n '2,4d' student.txt删除第二行到第四行，这个命令是删除显示在屏幕上的2到4行，并不是文件中的
                  如想要修改原文件，需要加-i
     sed -i '2a 11111111' student.txt表示在文件的第二行加上111111111，如果不加-i，表示在sed命令输							出的屏幕的第二行加上111111,并不会在原文件里面加
     sed '2i 22222222222' 表示在第二行的前面加上22222这些数据，这个命令只是在输出的屏幕上面加，并不会再原文文件里面加 sed -i '2i 22222'这条命令才会在原文件里面加
     sed -i '3c 66666666' 表示替换第三行的数据为666666
     sed -e -i '3d; 4d' 表示删除第三行和第四行，-e表示操作多行
     sed  -i 's/Lm/bols/g' student.txt表示把student.txt文件里面的Lm替换为bols
     sed -i 's/74/99/g ; s/Tg/cangls/g' student.txt表示替换多个值
     sed -e 's/Liming//g ; s/Tg//g' student.txt ==  sed -e 's/Liming//g' / +回车 s/Tg//s'           student.txt 表示同时把"Liming"和"Tg" 替换为空 
     
     
   ```


# 字符处理命令

1. 排序命令

   ```shell
   sort [选项] 文件名
   选项:
     -f:忽略大小写
     -b:忽略每行前面的空白行
     -n:以数值类型进行排序，默认使用字符串型排序
     -r:反向排序
     -u:删除重复行，就是uniq命令
     -t:指定分隔符，默认分隔符是制表符
     
     #指定分隔符是:，用第三字段开头，第三字段结尾排序，就是只用第三字段排序，下面将把第三例按字符串排序，按第一个字符的大小排序，如果要按数值的大小排序，需要加 -n
     sort -t ":" -k 3,3 /etc/passwd
     sort -n -t ":" -k 3,3 /etc/passwd
   ```

2. uniq

   ```shell
   uniq命令是用来取消重复行的命令，其实如"sort -u"选项是一样的。命令格式如下:
   uniq [选项] 文件名
   选项:
     -i: 忽略大小写
   ```

3. 统计命令wc

   ```shell
   wc [选项] 文件名
   选项:
      -l: 只统计行数
      -w: 只统计单词数
      -m: 只统计字符数
   ```

# 条件判断

1. 安装文件类型进行判断

   | 测试选项 | 作用                                                         |
   | -------- | ------------------------------------------------------------ |
   | -b 文件  | 判断文件是否存在，并且是否为块设备文件(是块设备文件就为真)   |
   | -c 文件  | 判断文件是否存在，并且是否为字符设备文件(是字符设备文件就为真) |
   | -d 文件  | 判断该文件是否存在，并且是否为目录文件(是目录为真)           |
   | -e 文件  | 判断该文件是否存在(存在为真)                                 |
   | -f 文件  | 判断该文件是否存在，并且是否为普通文件(是普通文件为真)       |
   | -L 文件  | 判断该文件是否存在，并且是否为符号链接文件(是符号链接文件为真) |
   | -p 文件  | 判断文件是否存在，并且是否为管道文件(是管道文件为真)         |
   | -s 文件  | 判断该文件是否存在，并且是否为空(非空为真)                   |
   | -S文件   | 判断该文件是否存在，并且是否为套接字文件(是套接字文件为真)   |

   ```shell
   #下面这台命令执行之后没有任何返回，这时我们就需要看这条命令的返回值  echo $?，如果这个命令的返回值是0，说明下面命令正确执行了，如果这台命令的返回值不是非0，说明没有正确执行
   test -e ip.txt 或者  [ -e abc ]
   [ -e abc ] && echo yes || echo no
   ```

2. 按照文件权限进行判断

   test是非车完善的判断命令，还可以判断文件的权限

   | 测试选项· | 作用                                                         |
   | --------- | ------------------------------------------------------------ |
   | -r 文件   | 判断该文件是否存在，并且是否该文件拥有读权限(有读权限为真)   |
   | -w 文件   | 判断该文件是否存在，并且是否该文件拥有写权限(有写权限为真)   |
   | -x 文件   | 判断该文件是否存在，并且是否该文件拥有执行权限(有执行权限为真) |
   | -u 文件   | 判断该文件是否存在，并且是否该文件拥有SUID权限(有SUID权限为真) |
   | -g 文件   | 判断该文件是否存在，并且是否该文件拥有SGID权限(有SGID权限为真) |
   | -k 文件   | 判断该文件是否存在，并且是否该文件拥有SBit权限(有SBit权限为真) |

3. 两个文件之间进行比较

   | 测试选项        | 作用                                                         |
   | --------------- | ------------------------------------------------------------ |
   | 文件1 -nt 文件2 | 判断文件1的修改时间是否比文件2的新(如果新则为真)             |
   | 文件1 -ot 文件2 | 判断文件1的修改时间是否比文件2的旧(如果旧则为真)             |
   | 文件1 -ef 文件2 | 判断文件1是否和文件2的Inode号一致，可以理解为两个文件是否为同一个文件，这个判断用于判断硬连接是很好的方法 |

4. 两个数之间比较

   | 测试选项         | 作用                                     |
   | ---------------- | ---------------------------------------- |
   | 整数1 -eq  整数2 | 判断整数1是否和整数2相等(相等为真)       |
   | 整数1 -ne 整数2  | 判断整数1是否和整数2不相等(不相等为真)   |
   | 整数1 -gt 整数2  | 判断整数1是否大于整数2(大于为真)         |
   | 整数1 -lt 整数2  | 判断整数1是否小于整数2(小于为真)         |
   | 整数1 -ge 整数2  | 判断整数1是否大于等于整数2(大于等于为真) |
   | 整数1 -le 整数2  | 判断整数1是否小于等于整数2(小于等于为真) |

5. 字符串判断

   | 测试选项           | 作用                                         |
   | ------------------ | -------------------------------------------- |
   | -z 字符串          | 判断字符串是否为空(为空返回真)               |
   | -n 字符串          | 判断字符串是否为非空(非空返回真)             |
   | 字符串1==字符串2   | 判断字符串1是否和字符串2相同(相同返回真)     |
   | 字符串1 ！=字符串2 | 判断字符串1是否和字符串2不相同(不相同返回真) |

6. 逻辑判断

   | 测试选项       | 作用                                             |
   | -------------- | ------------------------------------------------ |
   | 判断1 -a 判断2 | 逻辑与，判断1和判断2都成立，最终的结果才为真     |
   | 判断1 -o 判断2 | 逻辑或，判断1和判断2有一个成立，最终的结果就为真 |
   | ！判断         | 逻辑非，使原始的判断式取反                       |

# 流程控制

1. if条件判断

   ```shell
   if [ 条件判断 ];then
      程序
   fi
   或
   if [ 条件判断 ]
       then
         程序
   fi
   
   #单分支条件语句需要注意几个点:
     #1.if语句使用fi结尾，和一般语言使用大括号结尾不同
     #2.[ 条件判断式 ]就是用test命令判断，所以中括号和条件判断式之间必须有空格
     #3.then后面跟符合条件之后执行的程序，可以放在[]之后，用";"分隔，也可以换行写入，就不需要";"了
    df -h | grep /dev/sda3 | awk '{print $5}' | cut -d "%" -f 1
    aa=$(df -h | grep /dev/sda3 | awk '{print $5}' | cut -d "%" -f 1)
    if [ "$a" ge 80 ]
       then
          echo "666666"
    fi
   ```

2. 双分支if条件语句

   ```shell
   if [ 条件判断式 ]
      then
         条件成立时执行的程序
      else
         条件不成立时执行的程序
   fi
   
   #写一个数据备份的例子
   #!/bin/bash
   #同步系统时间
   ntpdate asia.pool.ntp.org &>/dev/null
   #把当前系统时间按照年月日格式赋予变量date
   date=$(date +%y%m%d)
   #统计mysql数据库的大小，并把大小赋予size变量
   size=$(du -sh /var/lib/mysql)
   #判断备份目录是否存在，是否为目录
   fi [ -d /tmp/dbbak ]
      then
     #1.进入备份目录,打包压缩数据库与临时文件，把所有输出丢入垃圾箱(不想看到任何输出)
      tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql/dbinfo.txt &>/dev/null
     #2.删除临时文件
       rm -rf /tmp/dbbak/dbinfo.txt
    else
      #3.如果判断为假
      
      
      
      
      
      #第二个例子,自动启服务
         #判断apache是否启动，如果没有启动，则自动启动
           aa=$(netstat -tuln | awk '{print $4}' | grep ":80$") 
         #使用nmap命令扫描服务器，并截取apache服务器的状态，赋予变量port
         port=$(nmap -sT 192.168.2.125 | grep tcp | grep http | awk 'print $2')
         #如果变量Port的值是open
         方法一
         if [ "$port"=="open" ]
              then
                 echo "$(date) httpd is ok!" >> /tmp/aoutostart-acc.log
                 #证明apache正常启动，在正常日志中写入一句话即可
              else
                 #否则证明apache没有启动，自动启动apache
                 /etc/rc.d/init.d/httpd start &>/dev/null
                 #并在错误日志中记录自动启动apache的时间
                 echo "$(date) restart httpd!!" >>/tmp/autostart-err.log
         fi
         
         方法二
         if ["$aa" ==""];then
             echo "httpd is down,must restart"
             /etc/rc.d/init.d/httpd start &>/dev/null
             else
              echo "httpd is ok"
         fi
         
      
   ```

3. 多分支if条件语句

   ```shell
   if [ 条件判断式1 ]
      then
        当条件判断式1成立时，执行程序1
   elif [ 条件判断式2 ]
      then
         当条件判断式2成立时，执行程序2
   ...省略更多条件...
   else
      当所有条件都不成立时，最后执行此程序
   fi
   ```

4. 四则运算

   ```shell
   #!/bin/bash
   #字符界面加减乘除计算器
   #通过read命令接收要计算的数值，并赋予变量num1和num2
   read -t 30 -p "Please input num1:"num1
   read -t 30 -p "Please input num2:"num2
   
   #通过read命令接收要计算的符号，并赋予变量ope
   read -t 30 -p "Please inout a operator:"ope
   
   #第一层判断，用来判断num1,num2,ope中的值都不为空
   if [ -n "$num1" -a -n "$num2" -a -n "$ope" ]
       then
       
       #定义变量test1和test2的值为$(命令)的结果
       #sed的命令的作用是把变量test1的值替换为空。如果能替换为空，证明num1的值为数字，如果不能替换为空，证明num1的值为非数字，我们使用这种方法判断变量num1的值为数字
       test1=$(echo $num1 | sed 's/[0-9]//g')
       test2=$(echo $num2 | sed 's/[0-9]//g')
       #判断test2和test2的值是否为空，如为空，说明num1和num2为数字
       if [ -z "$test1" -a -z "$test2" ]
          then
          #如何test1和test2是数字，则执行以下命令
          if [ "$ope" == "+" ]
              then
              value=$(( $num1 + $num2 ))
                  elif [ "$ope" == "-"]
                       then
                       value=$(($num1-$num2))
                  elif [ "$ope" == "*" ]
                       then
                       value=$(($num1*$num2))
                  elif [ "$ope" == "/" ]
                       then
                       value=$(($num1 / $num2))
               else 
                  #如果运算符不匹配，提示输入有效的符号
                 echo "Please enter a valid symbol"
                 #退出程序，返回错误代码10
                 exit 10
            fi
         #如果test1和test2不为空，说明num1和num2不是数字
        else
          echo "Please enter a valid value"
          #退出程序，返回错误代码11
          exit 11
        fi
   else
       echo "请输入内容"
       exit 12#这个地方是这个可执行文件的返回值
   fi
   
   ```

5. 多分支case条件语句

   case语句if...elif...else语句一样都是多分支条件语句，不过和if多分支条件语句不同的是，case语句只能判断一种条件关系，而if语句可以判断多种条件关系。case语句语法如下:

   ```shell
   case $变量名 in
     "值1")
     如果变量的值等于去，则执行程序1
     ;;
     "值2")
     如果变量的值等于值2，则执行程序2
     ;;
     *)
     如果变量的值都不是以上的值，则执行此程序
     ;;
     esac
     
     
     例子
     read -t -30 -p "please input your choice:" cho
     case $cho in 
        "1")
             echo "beijing"
               ;;
        "2"）
             echo "上海"
             ;;
         *)
           echo  "error input"
           ;;
      esac
   ```

6. for循环

   ```shell
   第一种写法
   for 变量 in 值1 值2 值3...
      do 
        程序
      done
      
   第二种写法
   for ((初始值;循环控制条件;变量变化))
        do
           程序
        done
        
        
   例子:批量解压缩
   #!/bin/bash
   cd /root/sh/tar
   ls *.tgz >> tar.log &>/dev/null
   aa=$(cat tar.log | wc -l)
   for((i=1;i<="$aa";i=i+1))
      do
        bb=$(cat tar.log | awk 'NR=='$i' {print $1}'')
        tar -zxvf $bb -C /root/sh/tar
      done
      
      
      
      批量解压的另一种写法
      #!/bin/bash
      ls *.tar.gz >tar.log
      for i in $(cat tar.log)
         do
            tar -zxvf $i
         done
   ```

7. 过滤ip的脚本

   ```shell
   #!/bin/bash
   
   #先通过正则，把明显不符合规则的ip过滤，把结果保存在ip_test1.txt临时文件中
   grep "^[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}$" /root/sh/ip_test1.txt
   
   #统计test1中有几行
   line=$(wc -l /root/sh/ip_test1.txt | awk '{print $1}')
   
   #清空最终数据文件
   echo "" > /root/sh/ip_test.txt
   
   #有几行ip，循环几次
   for((i=1;i<=$line;i=i+1))
     do
       cat /root/sh/ip_test1.txt | awk 'NR=='$i'{print}' > /root/sh/ip_test2.txt
       
       #第几次循环，就把第几行读入ip_test2.txt文件(此文件中只有一行ip)
       a=$(cat /root/sh/ip_test2.txt | cut -d'.' -f 1)
       b=$(cat /root/sh/ip_test2.txt | cut -d'.' -f 2)
       c=$(cat /root/sh/ip_test2.txt | cut -d'.' -f 3)
       d=$(cat /root/sh/ip_test2.txt | cut -d'.' -f 4)
       
       #如果第一个数值小于1或大于255
       if ["$a" -lt 1 -o "$a" -gt 255]
          then
          #则退出本次循环
          continue
        fi
        
        if [ "$b" -lt 0 -o "$b" -gt 255 ]
           then
           continue
         fi
         
          if [ "$c" -lt 0 -o "$c" -gt 255 ]
           then
           continue
         fi
         
          if [ "$c" -lt 0 -o "$c" -gt 255 ]
           then
           continue
         fi
         
         #依次判断四个ip数值是否超出范围，如果超出，退出本次循环
         cat /root/sh/ip_test2.txt >> /root/sh/ip_test.txt
     done
   ```

   